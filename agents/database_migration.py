"""Database Migration Agent — handles H2-to-Cloud SQL migration or H2 retention.

Responsibilities:
- Analyze H2 database mode (in-memory vs file-based)
- Recommend Cloud SQL setup OR keep H2 with warnings
- Optionally migrate data to Cloud SQL
- Update Spring Boot datasource configuration
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import Any, Dict, List, Optional

from agents.base import BaseAgent
from utils.gcp import GCPClient
from utils.logger import get_logger

log = get_logger(__name__)


class DatabaseMigrationAgent(BaseAgent):
    name = "database_migration"

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.gcp = GCPClient(self.config.gcp, dry_run=self.dry_run)

    # -- Tools ----------------------------------------------------------------

    def _analyze_h2_config(self, properties_path: str) -> Dict[str, Any]:
        """Analyze H2 database configuration from Spring Boot properties.

        Args:
            properties_path: Path to application.properties file.

        Returns:
            Dict with H2 mode, URL, username, console status, and warnings.
        """
        p = Path(properties_path)
        if not p.exists():
            return {"error": f"File not found: {properties_path}"}

        content = p.read_text()
        info: Dict[str, Any] = {
            "url": "",
            "mode": "unknown",
            "username": "",
            "h2_console_enabled": False,
            "ddl_auto": "",
            "warnings": [],
        }

        for line in content.splitlines():
            line = line.strip()
            if line.startswith("spring.datasource.url"):
                info["url"] = line.split("=", 1)[1].strip()
            elif line.startswith("spring.datasource.username"):
                info["username"] = line.split("=", 1)[1].strip()
            elif line.startswith("spring.h2.console.enabled"):
                info["h2_console_enabled"] = "true" in line.lower()
            elif line.startswith("spring.jpa.hibernate.ddl-auto"):
                info["ddl_auto"] = line.split("=", 1)[1].strip()

        url = info["url"]
        if "mem:" in url:
            info["mode"] = "in-memory"
            info["warnings"].append(
                "In-memory H2 data is lost on container restart. "
                "Consider Cloud SQL for persistent data."
            )
        elif "file:" in url or url.startswith("jdbc:h2:./"):
            info["mode"] = "file-based"
            info["warnings"].append(
                "File-based H2 requires persistent storage. Cloud Run containers "
                "are ephemeral. Strongly recommend migrating to Cloud SQL."
            )

        if info["ddl_auto"] in ("create", "create-drop"):
            info["warnings"].append(
                f"ddl-auto={info['ddl_auto']} will drop data on restart. "
                f"Consider 'update' or 'validate' for production."
            )

        return info

    def _generate_cloudsql_properties(
        self,
        instance_connection_name: str,
        database_name: str,
        username: str,
        password: str,
    ) -> str:
        """Generate Spring Boot datasource properties for Cloud SQL PostgreSQL.

        Args:
            instance_connection_name: Cloud SQL instance connection name (project:region:instance).
            database_name: Database name.
            username: Database username.
            password: Database password.

        Returns:
            Properties text to add to application.properties.
        """
        return (
            f"# --- Cloud SQL Configuration (generated by Cloudify) ---\n"
            f"spring.datasource.url=jdbc:postgresql:///{database_name}"
            f"?cloudSqlInstance={instance_connection_name}"
            f"&socketFactory=com.google.cloud.sql.postgres.SocketFactory\n"
            f"spring.datasource.username={username}\n"
            f"spring.datasource.password={password}\n"
            f"spring.datasource.driver-class-name=org.postgresql.Driver\n"
            f"spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect\n"
            f"spring.jpa.hibernate.ddl-auto=update\n"
        )

    def _generate_h2_cloud_properties(self) -> str:
        """Generate Spring Boot properties to keep H2 in-memory for Cloud Run.

        Returns:
            Properties text suitable for Cloud Run deployment with H2.
        """
        return (
            "# --- H2 In-Memory Configuration for Cloud Run (generated by Cloudify) ---\n"
            "spring.datasource.url=jdbc:h2:mem:appdb;DB_CLOSE_DELAY=-1\n"
            "spring.datasource.driver-class-name=org.h2.Driver\n"
            "spring.datasource.username=sa\n"
            "spring.datasource.password=\n"
            "spring.jpa.database-platform=org.hibernate.dialect.H2Dialect\n"
            "spring.jpa.hibernate.ddl-auto=update\n"
            "spring.h2.console.enabled=false\n"
        )

    # -- Agent interface -------------------------------------------------------

    def get_tools(self) -> list:
        return [
            self._analyze_h2_config,
            self._generate_cloudsql_properties,
            self._generate_h2_cloud_properties,
        ]

    def get_prompt(self) -> str:
        return (
            "You are a database migration specialist. Analyze the H2 database "
            "configuration and either migrate to Cloud SQL or keep H2 with "
            "appropriate warnings. Update Spring Boot datasource properties."
        )

    async def execute(self) -> Dict[str, Any]:
        """Analyze and handle database migration."""
        strategy = self.config.database.migration_strategy
        backend_path = self.config.source.backend_abs

        # Find application.properties
        props_file: Optional[Path] = None
        for candidate in backend_path.rglob("application.properties"):
            props_file = candidate
            break

        if props_file is None:
            # Check for YAML config
            for candidate in backend_path.rglob("application.yml"):
                props_file = candidate
                break

        h2_analysis: Dict[str, Any] = {}
        if props_file:
            h2_analysis = self._analyze_h2_config(str(props_file))
            self.log.info(f"H2 analysis: mode={h2_analysis.get('mode')}")
            for warning in h2_analysis.get("warnings", []):
                self.log.warning(f"DB Warning: {warning}")

        output: Dict[str, Any] = {
            "strategy": strategy,
            "h2_analysis": h2_analysis,
            "new_properties": "",
            "cloudsql_created": False,
        }

        if strategy == "migrate_cloudsql":
            self.log.info("Migrating to Cloud SQL...")
            sql_config = self.config.database.cloudsql
            instance_name = sql_config.instance_name
            project = self.config.gcp.project_id
            region = self.config.gcp.region

            # Create Cloud SQL instance
            result = self.gcp.create_cloudsql_instance(
                instance_name=instance_name,
                tier=sql_config.tier,
                database_version=sql_config.database_version,
            )
            if not result.success and "already exists" not in result.stderr and not self.dry_run:
                raise RuntimeError(f"Failed to create Cloud SQL: {result.stderr}")

            # Create database
            db_result = self.gcp.create_cloudsql_database(
                instance_name=instance_name,
                database_name=sql_config.database_name,
            )
            if not db_result.success and "already exists" not in db_result.stderr and not self.dry_run:
                raise RuntimeError(f"Failed to create database: {db_result.stderr}")

            connection_name = f"{project}:{region}:{instance_name}"
            new_props = self._generate_cloudsql_properties(
                instance_connection_name=connection_name,
                database_name=sql_config.database_name,
                username="postgres",
                password="changeme",  # User should configure via Secret Manager
            )

            output["new_properties"] = new_props
            output["cloudsql_created"] = True
            output["connection_name"] = connection_name

            self.log.info(f"Cloud SQL instance ready: {connection_name}")

        else:
            # Keep H2 — generate cloud-safe H2 properties
            self.log.info("Keeping H2 database (in-memory mode for Cloud Run)")
            new_props = self._generate_h2_cloud_properties()
            output["new_properties"] = new_props

            # LLM recommendation
            recommendation = await self.ask_llm(
                f"The application uses H2 database in {h2_analysis.get('mode', 'unknown')} mode. "
                f"The user chose to keep H2 for cloud deployment. "
                f"Provide a brief warning about data persistence implications on Cloud Run "
                f"and suggest when they should migrate to Cloud SQL. Keep it to 2-3 sentences."
            )
            output["recommendation"] = recommendation

        self.state.set_artifact("database", output)
        if self.dry_run:
            self.state.dry_run_scripts.extend(self.gcp.scripts)

        return output

    async def rollback(self) -> None:
        """Delete Cloud SQL instance if created."""
        if self.state.get_artifact("database", {}).get("cloudsql_created"):
            instance = self.config.database.cloudsql.instance_name
            self.log.info(f"Rolling back: deleting Cloud SQL instance {instance}")
            self.gcp.delete_cloudsql_instance(instance)
            self.agent_state.mark_rolled_back()
