"""Backend Deployment Agent â€” builds and deploys the Spring Boot app to Cloud Run.

Responsibilities:
- Generate optimized Dockerfile for Spring Boot
- Update application.properties with GCP configurations
- Build Docker image
- Push to Artifact Registry
- Deploy to Cloud Run
- Configure environment variables and secrets
"""

from __future__ import annotations

import shutil
from pathlib import Path
from typing import Any, Dict, List, Optional

from agents.base import BaseAgent
from utils.gcp import GCPClient
from utils.logger import get_logger

log = get_logger(__name__)

DOCKERFILE_MAVEN = """# --- Generated by Cloudify ---
# Multi-stage build for Spring Boot (Maven)
FROM maven:{maven_version}-eclipse-temurin-{java_version} AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn package -DskipTests -B

FROM eclipse-temurin:{java_version}-jre-alpine
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
ENV JAVA_OPTS="{jvm_opts}"
EXPOSE {port}
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
"""

DOCKERFILE_GRADLE = """# --- Generated by Cloudify ---
# Multi-stage build for Spring Boot (Gradle)
FROM gradle:{gradle_version}-jdk{java_version} AS build
WORKDIR /app
COPY build.gradle* settings.gradle* ./
COPY gradle ./gradle
RUN gradle dependencies --no-daemon || true
COPY src ./src
RUN gradle bootJar --no-daemon -x test

FROM eclipse-temurin:{java_version}-jre-alpine
WORKDIR /app
COPY --from=build /app/build/libs/*.jar app.jar
ENV JAVA_OPTS="{jvm_opts}"
EXPOSE {port}
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
"""


class BackendDeployerAgent(BaseAgent):
    name = "backend_deployer"

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.gcp = GCPClient(self.config.gcp, dry_run=self.dry_run)

    # -- Tools ----------------------------------------------------------------

    def _generate_dockerfile(
        self,
        build_tool: str,
        java_version: str,
        port: int,
        jvm_opts: str,
    ) -> str:
        """Generate an optimized multi-stage Dockerfile for Spring Boot.

        Args:
            build_tool: Either 'maven' or 'gradle'.
            java_version: Java version (e.g. '17', '21').
            port: Application port.
            jvm_opts: JVM options string.

        Returns:
            Dockerfile content as string.
        """
        if build_tool == "gradle":
            return DOCKERFILE_GRADLE.format(
                gradle_version="8.5",
                java_version=java_version,
                port=port,
                jvm_opts=jvm_opts,
            )
        return DOCKERFILE_MAVEN.format(
            maven_version="3.9",
            java_version=java_version,
            port=port,
            jvm_opts=jvm_opts,
        )

    def _update_application_properties(
        self,
        properties_path: str,
        new_properties: str,
        cloud_run_port: int,
    ) -> str:
        """Update or create application properties for cloud deployment.

        Args:
            properties_path: Path to application.properties file.
            new_properties: New property lines to add/replace.
            cloud_run_port: Port for Cloud Run (usually 8080).

        Returns:
            Path to the updated file.
        """
        p = Path(properties_path)
        content = p.read_text() if p.exists() else ""

        # Remove existing datasource properties (will be replaced)
        lines = content.splitlines()
        filtered = [
            line for line in lines
            if not any(
                line.strip().startswith(prefix)
                for prefix in [
                    "spring.datasource.",
                    "spring.h2.",
                    "spring.jpa.database-platform",
                    "spring.jpa.hibernate.ddl-auto",
                ]
            )
        ]

        # Add cloud config
        filtered.append("")
        filtered.append("# --- Cloud Run Configuration (generated by Cloudify) ---")
        filtered.append(f"server.port={cloud_run_port}")
        filtered.append("")
        filtered.append(new_properties)

        p.write_text("\n".join(filtered))
        return str(p)

    def _add_cors_for_firebase(
        self,
        backend_path: str,
        firebase_url: str,
    ) -> str:
        """Generate a Spring Boot CORS configuration class for Firebase frontend.

        Args:
            backend_path: Path to the backend source root.
            firebase_url: Firebase Hosting URL to allow.

        Returns:
            Path to the generated config file.
        """
        # Find the main package directory
        src_root = Path(backend_path) / "src" / "main" / "java"
        packages = list(src_root.rglob("*Application.java"))
        if packages:
            pkg_dir = packages[0].parent
        else:
            pkg_dir = src_root

        config_file = pkg_dir / "CloudifyCorsConfig.java"

        # Infer package name from directory structure
        try:
            rel = pkg_dir.relative_to(src_root)
            package_name = str(rel).replace("/", ".").replace("\\", ".")
        except ValueError:
            package_name = "com.app"

        config_content = f"""package {package_name};

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * CORS configuration for Cloud Run deployment.
 * Generated by Cloudify migration tool.
 */
@Configuration
public class CloudifyCorsConfig {{
    @Bean
    public WebMvcConfigurer corsConfigurer() {{
        return new WebMvcConfigurer() {{
            @Override
            public void addCorsMappings(CorsRegistry registry) {{
                registry.addMapping("/**")
                    .allowedOrigins("{firebase_url}", "http://localhost:3000")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true);
            }}
        }};
    }}
}}
"""
        config_file.write_text(config_content)
        return str(config_file)

    # -- Agent interface -------------------------------------------------------

    def get_tools(self) -> list:
        return [
            self._generate_dockerfile,
            self._update_application_properties,
            self._add_cors_for_firebase,
        ]

    def get_prompt(self) -> str:
        return (
            "You are a backend deployment specialist. Generate a Dockerfile, "
            "update application properties, build the Docker image, push it to "
            "Artifact Registry, and deploy to Cloud Run."
        )

    async def execute(self) -> Dict[str, Any]:
        """Build and deploy the Spring Boot backend to Cloud Run."""
        backend_path = self.config.source.backend_abs
        analysis = self.state.get_artifact("analysis_report", {})
        db_config = self.state.get_artifact("database", {})
        infra = self.state.get_artifact("infra", {})

        build_info = analysis.get("build_system", {})
        build_tool = build_info.get("build_tool", "maven")
        java_version = (
            build_info.get("java_version")
            or self.config.backend.java_version
        )

        service_name = self.config.backend.service_name
        port = self.config.backend.port
        image_base = infra.get("image_base_url", "")
        image_tag = f"{image_base}/{service_name}:latest"

        # Step 1: Generate Dockerfile
        self.log.info("Generating Dockerfile...")
        dockerfile_content = self._generate_dockerfile(
            build_tool=build_tool,
            java_version=java_version,
            port=port,
            jvm_opts=self.config.backend.jvm_opts,
        )
        dockerfile_path = backend_path / "Dockerfile"
        dockerfile_path.write_text(dockerfile_content)
        self.state.generated_files.append(str(dockerfile_path))
        self.log.info(f"Dockerfile written to {dockerfile_path}")

        # Step 2: Update application.properties
        new_db_props = db_config.get("new_properties", "")
        props_file = None
        for candidate in backend_path.rglob("application.properties"):
            props_file = candidate
            break
        if props_file:
            self.log.info("Updating application.properties...")
            self._update_application_properties(
                str(props_file), new_db_props, port
            )
            self.state.generated_files.append(str(props_file))

        # Step 3: Build Docker image
        self.log.info(f"Building Docker image: {image_tag}")
        build_result = self.gcp.docker_build(image_tag, str(backend_path))
        if not build_result.success and not self.dry_run:
            raise RuntimeError(f"Docker build failed: {build_result.stderr}")

        # Step 4: Push to Artifact Registry
        self.log.info(f"Pushing image to Artifact Registry...")
        push_result = self.gcp.docker_push(image_tag)
        if not push_result.success and not self.dry_run:
            raise RuntimeError(f"Docker push failed: {push_result.stderr}")

        # Step 5: Deploy to Cloud Run
        self.log.info(f"Deploying to Cloud Run: {service_name}")
        env_vars = dict(self.config.backend.env_vars)
        env_vars["JAVA_OPTS"] = self.config.backend.jvm_opts

        deploy_result = self.gcp.deploy_cloud_run(
            service_name=service_name,
            image=image_tag,
            port=port,
            memory=self.config.backend.memory,
            cpu=self.config.backend.cpu,
            min_instances=self.config.backend.min_instances,
            max_instances=self.config.backend.max_instances,
            env_vars=env_vars,
        )
        if not deploy_result.success and not self.dry_run:
            raise RuntimeError(f"Cloud Run deploy failed: {deploy_result.stderr}")

        # Step 6: Get service URL
        service_url = self.gcp.get_cloud_run_url(service_name) or ""
        if service_url:
            self.state.deployment_urls["backend"] = service_url
            self.log.info(f"Backend deployed at: {service_url}")

        output = {
            "service_name": service_name,
            "image_tag": image_tag,
            "service_url": service_url,
            "dockerfile_path": str(dockerfile_path),
        }

        self.state.set_artifact("backend_deployment", output)
        if self.dry_run:
            self.state.dry_run_scripts.extend(self.gcp.scripts)

        return output

    async def rollback(self) -> None:
        """Delete the Cloud Run service."""
        service_name = self.config.backend.service_name
        self.log.info(f"Rolling back: deleting Cloud Run service {service_name}")
        self.gcp.delete_cloud_run(service_name)
        self.agent_state.mark_rolled_back()
